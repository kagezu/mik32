#ifdef __AVR__
#include "init.h"

namespace Core {
  void init_clock()
  {
  #ifdef __ATMmega328P__
    TCCR0B |= _BV(CS00); // Включить тактирование
  #endif

  #ifdef __ATMmega128__
    TCCRB |= _BV(CS00); // Включить тактирование
  #endif
  }

  void init()
  {
    init_clock();
  }
}

/* Поддерживаемые частоты 1, 8, 12, 16, 20, 24 МГц F_CPU */
void delay_us(uint16_t us)
{
  // вызов функции занимает 14 (16) тактов

#if F_CPU >= 27000000L

  if (!us) return; // = 3 такта

  // 27 / 4 = 6.75 цикла на микросекунду
  us = (us << 1) + us; // x3 us, = 7 тактов
  us = (us << 1) + (us >> 2); // x2.25 us, = 7 + 4 = ? тактов

  // 24 такта, вычитаем 6
  us -= 6; // =2 такта
  if (!us) return; // = 3 такта
  // Вычитаем ещё 2
  us -= 2; // =2 такта
  // 31(33) такт, компенсировано (6+2)*4 = 32

#elif F_CPU >= 25000000L

  if (!us) return; // = 3 такта

  // 25 / 4 = 6.25 цикла на микросекунду
  us = us * 6 + (us >> 2); // x6.25 us, = 7 + 4 + 4 = 16 тактов

  // 32 такта, вычитаем 8
  us -= 8; // =2 такта
  if (!us) return; // = 3 такта
  // Вычитаем ещё 2
  us -= 2; // =2 такта
  // ~42 такт, компенсировано (8+2)*4 = 40

#elif F_CPU >= 24000000L

  if (!us) return; // = 3 такта

  // 24 / 4 = 6 цикла на микросекунду
  us *= 6; // x6 us, = 7 тактов

  // 24 такта, вычитаем 6
  us -= 6; // =2 такта
  if (!us) return; // = 3 такта
  // Вычитаем ещё 2
  us -= 2; // =2 такта
  // 31(33) такт, компенсировано (6+2)*4 = 32

#elif F_CPU >= 20000000L

  __asm__ __volatile__(
    "nop" "\n\t"
    "nop" "\n\t"
    "nop" "\n\t"
    "nop"); // 4 такта
  if (us <= 1) return; //  = 3 такта

  // 20 / 4 = 5 цикла на микросекунду
  us = (us << 2) + us; // x5 us, = 7 тактов
  us -= 8; // =2 такта
  // 30(32) тактов, компенсировано 8*4 = 32

#elif F_CPU >= 16000000L

  if (us <= 1) return; //  = 3 такта

  // 16 / 4 = 4 цикла на микросекунду
  us <<= 2; // x4 us, = 4 такта

  // 21 такт
  us -= 5; // = 2 такта
  // 23 такта, компенсировано 5*4 = 20

#elif F_CPU >= 12000000L
  if (us <= 1) return; //  = 3 такта

  // 12 / 4 = 3 цикла на микросекунду
  us = (us << 1) + us; // x3 us, = 7 тактов
  us -= 6; // 2 такта
  if (!us) return; //  = 3 такта
  us -= 2; // 2 такта
  // 31 такт, компенсировано (6+2)*4 = 32

#elif F_CPU >= 8000000L

  // 8 / 4 = 2 цикла на микросекунду
  if (us <= 2) return; //  = 3 такта
  us <<= 1; //x2 us, = 2 такта
  us -= 5; // = 2 такта
  // 21 такт, компенсировано 5*4 = 20

#else
// Предполагается 1 МГц, 4 us один цикл
  if (us <= 16) return; //  = 3 такта
  if (us <= 25) return; //  = 3 такта
  us -= 22; //  = 2 такта
  us >>= 2; //  = 4 такта
#endif

  __asm__ __volatile__(
    "1: sbiw %0,1" "\n\t"             // 2 такта
    "brne 1b" : "=w" (us) : "0" (us)  // 2 такта
  );
  // return = 4 такта
}

void delay_ms(uint16_t ms)
{
  while (ms--) delay_us(999);
}

#endif
